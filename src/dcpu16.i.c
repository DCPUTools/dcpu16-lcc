#include "dcpu16.i.h"

static int header = 0, usemain = 1;
static int dasmplus = 0;

static void progbeg(int argc, char *argv[])
{
    int i;

    {
        union
        {
            char c;
            int i;
        } u;
        u.i = 0;
        u.c = 1;
        swap = ((int) (u.i == 1)) != IR->little_endian;
    }
    parseflags(argc, argv);

    //put both ints and floats into IREG set
    reg[RGA] = mkreg("A", RGA, 1, IREG);
    reg[RGB] = mkreg("B", RGB, 1, IREG);
    reg[RGC] = mkreg("C", RGC, 1, IREG);
    reg[RGX] = mkreg("X", RGX, 1, IREG);
    reg[RGY] = mkreg("Y", RGY, 1, IREG);
    reg[RGZ] = mkreg("Z", RGZ, 1, IREG);
    reg[RGI] = mkreg("I", RGI, 1, IREG);

    regw = mkwildcard(reg);

    tmask[IREG] = TMP_REG;
    vmask[IREG] = VAR_REG;
    tmask[FREG] = 0;
    vmask[FREG] = 0;

    print(";\n;DCPU-16 ASM Generated by LCC 4.2 (dcpu16-lcc v0.2)\n;\n");
    print("JSR _global_main\n");
}

static void progend(void)
{

}

static Symbol rmap(int opk)
{
    switch (optype(opk))
    {
        case B:
        case P:
        case I:
        case U:
        case F:
            return regw;
        default:
            return 0;
    }
}

static void segment(int n)
{

}

static void target(Node p)
{
    /*
     debug({
     fprintf(stderr, "target called on %x (%s)\n", p, opname(p->op));
     if (p->syms[RX])
     fprintf(stderr, "    sclass: %d, name: %s\n", p->syms[RX]->sclass, p->syms[RX]->name);
     if (p->kids[0]) {
     fprintf(stderr, "    %x (%s)\n", p->kids[0], opname(p->kids[0]->op));
     if (p->kids[0]->syms[RX])
     fprintf(stderr, "        sclass: %d, name: %s\n", p->kids[0]->syms[RX]->sclass, p->kids[0]->syms[RX]->name);
     }
     if (p->kids[1]) {
     fprintf(stderr, "    %x (%s)\n", p->kids[1], opname(p->kids[1]->op));
     if (p->kids[1]->syms[RX])
     fprintf(stderr, "        sclass: %d, name: %s\n", p->kids[1]->syms[RX]->sclass, p->kids[1]->syms[RX]->name);
     }
     });
     */
    assert(p);
    switch (specific(p->op))
    {
        case RET + F:
        case RET + I:
        case RET + U:
        case RET + P:
            rtarget(p, 0, reg[RGA]);
            break;
        case CALL + F:
        case CALL + I:
        case CALL + U:
        case CALL + P:
            setreg(p, reg[RGA]);
            break;
        case ARG + F:
        case ARG + I:
        case ARG + U:
        case ARG + P:
            switch (p->x.argno)
            {
                case 0:
                    debug(
                            fprintf(stderr, "target called on ARG with argno = %d, targetting A\n", p->x.argno));
                    spill(1 << RGA, IREG, p);
                    rtarget(p, 0, reg[RGA]);
                    break;
                case 1:
                    debug(
                            fprintf(stderr, "target called on ARG with argno = %d, targetting B\n", p->x.argno));
                    spill(1 << RGB, IREG, p);
                    rtarget(p, 0, reg[RGB]);
                    break;
                case 2:
                    debug(
                            fprintf(stderr, "target called on ARG with argno = %d, targetting C\n", p->x.argno));
                    spill(1 << RGC, IREG, p);
                    rtarget(p, 0, reg[RGC]);
                    break;
                default:
                    debug(
                            fprintf(stderr, "target called on ARG with argno = %d, skipping\n", p->x.argno));
            }
            break;
    }

    /*
     debug({
     fprintf(stderr, "target returning on %x (%s)\n", p, opname(p->op));
     if (p->syms[RX])
     fprintf(stderr, "    sclass: %d, name: %s\n", p->syms[RX]->sclass, p->syms[RX]->name);
     if (p->kids[0]) {
     fprintf(stderr, "    %x (%s)\n", p->kids[0], opname(p->kids[0]->op));
     if (p->kids[0]->syms[RX])
     fprintf(stderr, "        sclass: %d, name: %s\n", p->kids[0]->syms[RX]->sclass, p->kids[0]->syms[RX]->name);
     }
     if (p->kids[1]) {
     fprintf(stderr, "    %x (%s)\n", p->kids[1], opname(p->kids[1]->op));
     if (p->kids[1]->syms[RX])
     fprintf(stderr, "        sclass: %d, name: %s\n", p->kids[1]->syms[RX]->sclass, p->kids[1]->syms[RX]->name);
     }
     });
     */
}

static void clobber(Node p)
{
    assert(p);
    switch (generic(p->op))
    {
        case CALL:
            spill(TMP_REG, IREG, p);
            break;
    }
}

static void emit2(Node p)
{
    char* name;
    char* offset;
    int localoffset;
    int argoffset;
    long intval;
    long double fltval;
    int op = specific(p->op);
    int opsz = opsize(p->op);
    int i, j, k;
    Symbol s;

    switch (op)
    {
        case CNST + F:
            fltval = p->syms[0]->u.c.v.d;
            if (fltval < 0)
                emithex((short) (fltval * 256));
            else
                printf("%d", (short) (fltval * 256));
            break;
        case CNST + I:
            intval = p->syms[0]->u.c.v.i;
            if (intval < 0)
                emithex((short) intval);
            else
                print("%d", intval);
            break;
        case ARG + F:
        case ARG + I:
        case ARG + U:
        case ARG + P:
            if (p->x.argno > 2)
            {
                assert(maxargoffset);
                if (p->x.argno == 3)
                    print("SET PEEK, ");
                else
                    print("SET I, SP\nSET [%d+I], ", p->x.argno - 3);
                emitasm(p->kids[0], _bval_NT);
                print("\n");
            }
            break;
        case CALL + F:
        case CALL + I:
        case CALL + U:
        case CALL + P:
        case CALL + V:
            assert(p->kids[0]);
            argoffset = p->syms[0]->u.c.v.i;

            print("JSR ");
            emitasm(p->kids[0], _addr_NT);
            print("\n");
            if (argoffset > 3)
                popstack(argoffset - 3, "popping arguments from stack");
            break;
        case ADDRL + P:
            localoffset = p->syms[0]->x.offset + maxoffset;
            if (p->x.inst)
            {
                if (localoffset)
                    print("SET %s, %d\nADD %s, J\n", p->syms[RX]->name,
                            localoffset, p->syms[RX]->name);
                else
                    print("SET %s, J\n", p->syms[RX]->name);
            }
            else
            {
                if (localoffset)
                    print("%d+J", localoffset);
                else
                    print("J");
            }
            break;
        case ADDRF + P:
            if (p->syms[0]->x.offset)
                print("%d+J", p->syms[0]->x.offset);
            else
                print("J");
            break;
        case ASGN + B:
            assert(p->kids[0]);
            assert(p->kids[1]);
            assert(p->kids[1]->kids[0]);

            print(";starting block copy (%s %s %d)\n",
                    p->kids[0]->syms[RX]->x.name,
                    p->kids[1]->kids[0]->syms[RX]->x.name, p->syms[0]->u.c.v.i);

            for (i = 0; i < p->syms[0]->u.c.v.i; i++)
            {
                if (i == 0)
                    print("SET [%s], [%s]\n", p->kids[0]->syms[RX]->x.name,
                            p->kids[1]->kids[0]->syms[RX]->x.name);
                else
                    print("SET [%d+%s], [%d+%s]\n", i,
                            p->kids[0]->syms[RX]->x.name, i,
                            p->kids[1]->kids[0]->syms[RX]->x.name);
            }

            break;
            /*
             case INDIR+P:
             if (p->kids[0]) {
             s = p->kids[0]->syms[0];
             }
             else {
             s = p->syms[0];
             }

             assert(s->x.name);
             debug(fprintf(stderr, "addrg emit2 %s->%s\n", s->x.name, p->syms[RX]->name));

             name = (char*)malloc(strlen(s->x.name));
             offset = (char*)malloc(strlen(s->x.name));
             for( i = 0; s->x.name[i]; i++ ) {
             if ( s->x.name[i] == '+' )
             break;
             name[i] = s->x.name[i];
             }
             name[i+1] = 0;
             if (s->x.name[i] == '+') {
             i++;
             for( j = 0; s->x.name[i+j]; j++ ) {
             offset[j] = s->x.name[i+j];
             }
             offset[i+j+1] = 0;

             print("SET %s, %s\nADD %s, %s\nSET %s, [%s]\n", p->syms[RX]->name, name, p->syms[RX]->name, offset, p->syms[RX]->name, p->syms[RX]->name);
             }
             else {
             print("SET %s, [", p->syms[RX]->name);
             emithex(atoi(s->x.name));
             print("]\n");
             }

             break;
             */
    }
}

static void emithex(short i)
{
    printf("0x%c%c%c%c", hexdigits[i >> 12 & 0x000f],
            hexdigits[i >> 8 & 0x000f], hexdigits[i >> 4 & 0x000f],
            hexdigits[i & 0x000f]);
}

static void doarg(Node p)
{
    static int argno;
    assert(p && p->syms[0]);
    if (argoffset == 0)
        argno = 0;

    p->x.argno = argno++;
    p->syms[2] = intconst(mkactual(1, p->syms[0]->u.c.v.i));
    debug(fprintf(stderr, "doarg done with argoffset=%d\n", argoffset));
}

static void blkfetch(int k, int off, int reg, int tmp)
{
}
static void blkstore(int k, int off, int reg, int tmp)
{
}
static void blkloop(int dreg, int doff, int sreg, int soff, int size,
        int tmps[])
{
}

static void local(Symbol p)
{
    debug(fprintf(stderr, "local called on '%s'\n", p->name));
    if (askregvar(p, (*IR->x.rmap)(ttob(p->type))) == 0)
    {
        mkauto(p);
    }
}

static void function(Symbol f, Symbol caller[], Symbol callee[], int ncalls)
{

    /* Call stack layout:
     +---------------------------
     |
     | Incoming Arguments
     |
     +--------------------------- <-- Frame Begin
     | Return Address
     +---------------------------
     |
     | Pushed Register Arguments
     |
     +---------------------------
     |
     | Locals
     |                           <-- Frame Pointer (J)
     +---------------------------
     | Previous Frame Pointer
     +---------------------------
     |
     | Outgoing Arguments
     |                           <-- SP
     +--------------------------- <-- Frame End
     */
    int i, nreg, nfreg, nargs, pushregargs[3];
    long fused;
    Symbol fs;
    Symbol r;
    Symbol tmp;
    Symbol local;

    usedmask[IREG] = 0;
    usedmask[FREG] = 0;
    freemask[IREG] = TMP_REG | (1 << RGA) | (1 << RGB) | (1 << RGC);
    freemask[FREG] = 0;

    maxargoffset = 0;
    offset = maxoffset = 0;
    pushregargs[0] = pushregargs[1] = pushregargs[2] = 0;

    for (i = 0; callee[i]; i++)
    {
        Symbol p = callee[i];
        Symbol q = caller[i];

        assert(q);

        switch (i)
        {
            case 0:
                if (ncalls || f->type->type->op != VOID)
                {
                    p->x.offset = q->x.offset = 1;
                    p->sclass = q->sclass = AUTO;
                    pushregargs[0] = 1;
                    break;
                }
            case 1:
            case 2:
                if (ncalls)
                {
                    p->x.offset = q->x.offset = 1;
                    p->sclass = q->sclass = AUTO;
                    pushregargs[i] = 1;
                    break;
                }
                r = reg[i];
                p->sclass = q->sclass = REGISTER;
                p->x.offset = q->x.offset = 0;
                p->x.name = q->x.name = r->x.name;
                p->x.regnode = r->x.regnode;
                p->x.regnode->vbl = p;
                q->x = p->x;
                q->type = p->type;
                break;
            default:
                p->x.offset = q->x.offset = 1;
                p->sclass = q->sclass = AUTO;
                break;
        }
    }
    nargs = i;
    offset = maxoffset = 0;

    debug(fprintf(stderr, "function: calling gencode\n"));

    gencode(caller, callee);

    maxargoffset = maxargoffset > 2 ? maxargoffset - 3 : 0;
    debug(
            fprintf(stderr, "function: gencode done.  maxargoffset = %d\n", maxargoffset));

    offset = maxoffset;
    for (i = 0; callee[i]; i++)
    {
        Symbol p = callee[i];
        Symbol q = caller[i];
        assert(q);

        if (i < 3 && pushregargs[i])
        {
            p->x.offset = q->x.offset = offset;
            p->x.name = q->x.name = stringf("%d", p->x.offset);
            offset += roundup(q->type->size,q->type->align);
        }
        else if (i >= 3)
        {
            p->x.offset = q->x.offset = offset + 1;
            p->x.name = q->x.name = stringf("%d", p->x.offset);
            offset += roundup(q->type->size,q->type->align);
        }
    }

    // prologue
    print(":%s\n", f->x.name);
    if (!(strcmp(f->name, "main") == 0 && usemain))
    {
        if (pushregargs[2])
            print("SET PUSH, C\n");
        if (pushregargs[1])
            print("SET PUSH, B\n");
        if (pushregargs[0])
            print("SET PUSH, A\n");
    }

    pushstack(maxoffset, "making room on stack for locals");

    if (!(strcmp(f->name, "main") == 0 && usemain))
    {
        print("SET I, J\n");
        print("SET J, SP    ;set new frame pointer\n");
        print("SET PUSH, I  ;save previous frame pointer\n");
    }
    else
    {
        print("SET J, SP    ;set new frame pointer\n");
    }

    pushstack(maxargoffset, "making room on stack for outgoing arguments");

    emitcode();

    if (!(strcmp(f->name, "main") == 0 && usemain))
    {
        //epilogue
        print("SET J, POP   ;restore previous frame pointer\n");
        popstack(maxoffset + pushregargs[0] + pushregargs[1] + pushregargs[2],
                "popping locals and register arguments from stack");
        print("SET PC, POP\n");
    }
    else
    {
        print("SUB PC, 1\n");
    }
}

static void defsymbol(Symbol p)
{
    debug(
            { if (p->type) fprintf(stderr, "defsymbol called on %s %d\n", p->name, p->type->op); else fprintf(stderr, "defsymbol called on %s %d\n", p->name, p->scope);

            });
    if (p->scope >= LOCAL && p->sclass == STATIC)
        p->x.name = stringf("_S%d", genlabel(1));
    else if (p->generated)
        p->x.name = stringf("_L%s", p->name);
    else if (p->scope == GLOBAL || p->sclass == EXTERN)
        p->x.name = stringf("_global_%s", p->name);
    //else if (p->scope == CONSTANTS && (isint(p->type) || isptr(p->type)) && p->name[0] == '0' && p->name[1] == 'x')
    //    p->x.name = stringf("_%s", &p->name[2]);
    else
        p->x.name = p->name;
}

static void address(Symbol q, Symbol p, long n)
{
    if (p->scope == GLOBAL || p->sclass == STATIC || p->sclass == EXTERN)
        q->x.name = stringf("%s%s%D", p->x.name, n >= 0 ? "+" : "", n);
    else
    {
        assert(n <= INT_MAX && n >= INT_MIN);
        q->x.offset = p->x.offset + n;
        q->x.name = stringd(q->x.offset);
    }
}

static void defconst(int suffix, int size, Value v)
{
    if (suffix == F && size == 1)
    {
        if (v.d < 0)
        {
            print("DAT ");
            emithex((short) (v.d * 256));
            print(" ;%f\n", v.d);
        }
        else
        {
            print("DAT %d ;%f\n", (short) (v.d * 256), v.d);
        }
    }
    else if (suffix == I && size == 1)
    {
        if (v.i < 0)
        {
            print("DAT ");
            emithex((short) v.i);
            print(" ;%d\n", v.i);
        }
        else
        {
            print("DAT %d\n", v.i);
        }
    }
    else if (suffix == U && size == 1)
    {
        print("DAT %d\n", (unsigned) v.u);
    }
    else if (suffix == P && size == 1)
    {
        print("DAT %d\n", (unsigned) v.p);
    }
    else
        assert(0);
}

static void defaddress(Symbol p)
{
    print("DAT %s\n", p->x.name);
}

static void defstring(int n, char *str)
{
    int i;
    char buf[32768];

    memcpy(buf, str, n);
    buf[n] = (char) 0;
    for (i = 0; i < n; i++)
    {
        short v = (short) (*(str + i));
        if (i == 0)
        {
            print("DAT ");
            emithex(v);
        }
        else
        {
            print(",");
            emithex(v);
        }
    }
    //print("\n");
    print(" ;string\n", buf);
}

static void export(Symbol p)
{
    debug(fprintf(stderr, "export called %s\n", p->name));
}

static void import(Symbol p)
{
    debug(fprintf(stderr, "import called %s\n", p->name));
}

static void global(Symbol p)
{
    //assert(p->type->align == 1);
    print(":%s\n", p->x.name);
}

static void space(int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        if (i == 0)
        {
            print("DAT 0");
        }
        else
        {
            print(",0");
        }
    }
    print("\n");
}

static void pushstack(int n, const char* note)
{
    if (n > 1)
        print("SUB SP, %d    ;%s\n", n, note);
    else if (n == 1)
        print("SET PUSH, 0  ;%s\n", note);
}

static void popstack(int n, const char* note)
{
    if (n > 1)
        print("ADD SP, %d    ;%s\n", n, note);
//    else if (n == 2)
//        print("SET EX, POP ;%s\n", note);
    else if (n == 1)
        print("SET EX, POP  ;%s\n", note);
}

static int addrgop(Node p, int defaultcost)
{
    assert(p);
    if (!p->syms[0])
        return defaultcost;

    debug(fprintf(stderr, "addgop: %s\n", p->syms[0]->x.name));
    char* name;
    int nope = 0;
    name = p->syms[0]->x.name;
    while (*name)
    {
        if (*name == '+')
        {
            nope = 1;
            break;
        }
        name++;
    }

    if (nope)
        return LBURG_MAX;
    return defaultcost;
}

static int ncregop(Node p, int defaultcost)
{
    assert(p);
    assert(p->kids[0]);
    assert(p->kids[1]);
    debug(
            fprintf(stderr, "ncregop %s %s\n", p->syms[RX]->name, p->kids[1]->syms[RX]->name));

    if (p->syms[RX] == p->kids[1]->syms[RX])
        return LBURG_MAX;
    else
        return defaultcost;
}

static int regopu(Node p, int defaultcost)
{
    assert(p);
    assert(p->kids[0]);

    if (p->syms[RX] == p->kids[0]->syms[RX])
        return LBURG_MAX;
    else
        return defaultcost;
}

static int memop(Node p, int defaultcost)
{
    assert(p);
    assert(generic(p->op) == ASGN);
    assert(p->kids[0]);
    assert(p->kids[1]);

    if (generic(p->kids[1]->kids[0]->op) == INDIR
            && sametree(p->kids[0], p->kids[1]->kids[0]->kids[0]))
        return defaultcost;
    else
        return LBURG_MAX;
}

static int memopu(Node p, int defaultcost)
{
    assert(p);
    assert(generic(p->op) == ASGN);
    assert(p->kids[0]);
    assert(p->kids[1]);

    if (generic(p->kids[1]->kids[0]->op) == INDIR
            && sametree(p->kids[0], p->kids[1]->kids[0]->kids[0]))
        return LBURG_MAX;
    else
        return defaultcost;
}

static int ncmemop(Node p, int defaultcost)
{
    assert(p);
    assert(generic(p->op) == ASGN);
    assert(p->kids[0]);
    assert(p->kids[1]);

    if (generic(p->kids[1]->kids[1]->op) == INDIR
            && sametree(p->kids[0], p->kids[1]->kids[1]->kids[0]))
        return LBURG_MAX;
    else
        return defaultcost;
}

static int sametree(Node p, Node q)
{
    return p == NULL && q == NULL
            || p && q && p->op == q->op && p->syms[0] == q->syms[0]
                    && sametree(p->kids[0], q->kids[0])
                    && sametree(p->kids[1], q->kids[1]);
}

Interface dcpu16IR = {  1, 1, 0, /* char */

1, 1, 0, /* short */
1, 1, 0, /* int */
2, 2, 0, /* long */
4, 4, 0, /* long long */
1, 1, 0, /* float */
2, 2, 0, /* double */
4, 4, 0, /* long double */
1, 1, 0, /* T * */
0, 1, 0, /* struct */
0, /* little_endian */
1, /* mulops_calls */
0, /* wants_callb */
0, /* wants_argb */
1, /* left_to_right */
0, /* wants_dag */
1, /* unsigned_char */
16, /* width */
address, blockbeg, blockend, defaddress, defconst, defstring, defsymbol, emit,
        export, function, gen, global, import, local, progbeg, progend, segment,
        space, 0, 0, 0, 0, 0, 0, 0, { 1, rmap, blkfetch, blkstore, blkloop,
                _label, _rule, _nts, _kids, _string, _templates, _isinstruction,
                _ntname, emit2, doarg, target, clobber, } };
static char rcsid[] = "$Id: $";
